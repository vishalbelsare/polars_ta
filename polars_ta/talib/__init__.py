# generated by codegen_talib.py
import talib as _ta
from polars import Expr, struct, Struct, Field, Float64, Int32

from polars_ta.utils.numba_ import batches_i1_o1, batches_i1_o2, batches_i2_o1, batches_i2_o2, struct_to_numpy


def HT_DCPERIOD(close: Expr) -> Expr:  # ['real']
    """HT_DCPERIOD(ndarray real)

HT_DCPERIOD(real)

Hilbert Transform - Dominant Cycle Period (Cycle Indicators)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.HT_DCPERIOD), return_dtype=Float64)


def HT_DCPHASE(close: Expr) -> Expr:  # ['real']
    """HT_DCPHASE(ndarray real)

HT_DCPHASE(real)

Hilbert Transform - Dominant Cycle Phase (Cycle Indicators)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.HT_DCPHASE), return_dtype=Float64)


def HT_PHASOR(close: Expr) -> Expr:  # ['inphase', 'quadrature']
    """HT_PHASOR(ndarray real)

HT_PHASOR(real)

Hilbert Transform - Phasor Components (Cycle Indicators)

Inputs:
    real: (any ndarray)
Outputs:
    inphase
    quadrature"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(2)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.HT_PHASOR), return_dtype=dtype)


def HT_SINE(close: Expr) -> Expr:  # ['sine', 'leadsine']
    """HT_SINE(ndarray real)

HT_SINE(real)

Hilbert Transform - SineWave (Cycle Indicators)

Inputs:
    real: (any ndarray)
Outputs:
    sine
    leadsine"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(2)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.HT_SINE), return_dtype=dtype)


def HT_TRENDMODE(close: Expr) -> Expr:  # ['integer']
    """HT_TRENDMODE(ndarray real)

HT_TRENDMODE(real)

Hilbert Transform - Trend vs Cycle Mode (Cycle Indicators)

Inputs:
    real: (any ndarray)
Outputs:
    integer (values are -100, 0 or 100)"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.HT_TRENDMODE), return_dtype=Int32)


def ADD(high: Expr, low: Expr) -> Expr:  # ['real']
    """ADD(ndarray real0, ndarray real1)

ADD(real0, real1)

Vector Arithmetic Add (Math Operators)

Inputs:
    real0: (any ndarray)
    real1: (any ndarray)
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.ADD), return_dtype=Float64)


def DIV(high: Expr, low: Expr) -> Expr:  # ['real']
    """DIV(ndarray real0, ndarray real1)

DIV(real0, real1)

Vector Arithmetic Div (Math Operators)

Inputs:
    real0: (any ndarray)
    real1: (any ndarray)
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.DIV), return_dtype=Float64)


def MAX(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """MAX(ndarray real, int timeperiod=-0x80000000)

MAX(real[, timeperiod=?])

Highest value over a specified period (Math Operators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MAX, timeperiod), return_dtype=Float64)


def MAXINDEX(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['integer']
    """MAXINDEX(ndarray real, int timeperiod=-0x80000000)

MAXINDEX(real[, timeperiod=?])

Index of highest value over a specified period (Math Operators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    integer (values are -100, 0 or 100)"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MAXINDEX, timeperiod), return_dtype=Int32)


def MIN(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """MIN(ndarray real, int timeperiod=-0x80000000)

MIN(real[, timeperiod=?])

Lowest value over a specified period (Math Operators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MIN, timeperiod), return_dtype=Float64)


def MININDEX(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['integer']
    """MININDEX(ndarray real, int timeperiod=-0x80000000)

MININDEX(real[, timeperiod=?])

Index of lowest value over a specified period (Math Operators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    integer (values are -100, 0 or 100)"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MININDEX, timeperiod), return_dtype=Int32)


def MINMAX(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['min', 'max']
    """MINMAX(ndarray real, int timeperiod=-0x80000000)

MINMAX(real[, timeperiod=?])

Lowest and highest values over a specified period (Math Operators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    min
    max"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(2)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MINMAX, timeperiod), return_dtype=dtype)


def MINMAXINDEX(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['minidx', 'maxidx']
    """MINMAXINDEX(ndarray real, int timeperiod=-0x80000000)

MINMAXINDEX(real[, timeperiod=?])

Indexes of lowest and highest values over a specified period (Math Operators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    minidx
    maxidx"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(2)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MINMAXINDEX, timeperiod), return_dtype=dtype)


def MULT(high: Expr, low: Expr) -> Expr:  # ['real']
    """MULT(ndarray real0, ndarray real1)

MULT(real0, real1)

Vector Arithmetic Mult (Math Operators)

Inputs:
    real0: (any ndarray)
    real1: (any ndarray)
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.MULT), return_dtype=Float64)


def SUB(high: Expr, low: Expr) -> Expr:  # ['real']
    """SUB(ndarray real0, ndarray real1)

SUB(real0, real1)

Vector Arithmetic Subtraction (Math Operators)

Inputs:
    real0: (any ndarray)
    real1: (any ndarray)
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.SUB), return_dtype=Float64)


def SUM(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """SUM(ndarray real, int timeperiod=-0x80000000)

SUM(real[, timeperiod=?])

Summation (Math Operators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SUM, timeperiod), return_dtype=Float64)


def ACOS(close: Expr) -> Expr:  # ['real']
    """ACOS(ndarray real)

ACOS(real)

Vector Trigonometric ACos (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ACOS), return_dtype=Float64)


def ASIN(close: Expr) -> Expr:  # ['real']
    """ASIN(ndarray real)

ASIN(real)

Vector Trigonometric ASin (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ASIN), return_dtype=Float64)


def ATAN(close: Expr) -> Expr:  # ['real']
    """ATAN(ndarray real)

ATAN(real)

Vector Trigonometric ATan (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ATAN), return_dtype=Float64)


def CEIL(close: Expr) -> Expr:  # ['real']
    """CEIL(ndarray real)

CEIL(real)

Vector Ceil (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.CEIL), return_dtype=Float64)


def COS(close: Expr) -> Expr:  # ['real']
    """COS(ndarray real)

COS(real)

Vector Trigonometric Cos (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.COS), return_dtype=Float64)


def COSH(close: Expr) -> Expr:  # ['real']
    """COSH(ndarray real)

COSH(real)

Vector Trigonometric Cosh (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.COSH), return_dtype=Float64)


def EXP(close: Expr) -> Expr:  # ['real']
    """EXP(ndarray real)

EXP(real)

Vector Arithmetic Exp (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.EXP), return_dtype=Float64)


def FLOOR(close: Expr) -> Expr:  # ['real']
    """FLOOR(ndarray real)

FLOOR(real)

Vector Floor (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.FLOOR), return_dtype=Float64)


def LN(close: Expr) -> Expr:  # ['real']
    """LN(ndarray real)

LN(real)

Vector Log Natural (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LN), return_dtype=Float64)


def LOG10(close: Expr) -> Expr:  # ['real']
    """LOG10(ndarray real)

LOG10(real)

Vector Log10 (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LOG10), return_dtype=Float64)


def SIN(close: Expr) -> Expr:  # ['real']
    """SIN(ndarray real)

SIN(real)

Vector Trigonometric Sin (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SIN), return_dtype=Float64)


def SINH(close: Expr) -> Expr:  # ['real']
    """SINH(ndarray real)

SINH(real)

Vector Trigonometric Sinh (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SINH), return_dtype=Float64)


def SQRT(close: Expr) -> Expr:  # ['real']
    """SQRT(ndarray real)

SQRT(real)

Vector Square Root (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SQRT), return_dtype=Float64)


def TAN(close: Expr) -> Expr:  # ['real']
    """TAN(ndarray real)

TAN(real)

Vector Trigonometric Tan (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TAN), return_dtype=Float64)


def TANH(close: Expr) -> Expr:  # ['real']
    """TANH(ndarray real)

TANH(real)

Vector Trigonometric Tanh (Math Transform)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TANH), return_dtype=Float64)


def ADX(high: Expr, low: Expr, close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """ADX(ndarray high, ndarray low, ndarray close, int timeperiod=-0x80000000)

ADX(high, low, close[, timeperiod=?])

Average Directional Movement Index (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.ADX, timeperiod), return_dtype=Float64)


def ADXR(high: Expr, low: Expr, close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """ADXR(ndarray high, ndarray low, ndarray close, int timeperiod=-0x80000000)

ADXR(high, low, close[, timeperiod=?])

Average Directional Movement Index Rating (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.ADXR, timeperiod), return_dtype=Float64)


def APO(close: Expr, fastperiod: float = 12.0, slowperiod: float = 26.0, matype: float = 0.0) -> Expr:  # ['real']
    """APO(ndarray real, int fastperiod=-0x80000000, int slowperiod=-0x80000000, int matype=0)

APO(real[, fastperiod=?, slowperiod=?, matype=?])

Absolute Price Oscillator (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    fastperiod: 12
    slowperiod: 26
    matype: 0 (Simple Moving Average)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.APO, fastperiod, slowperiod, matype), return_dtype=Float64)


def AROON(high: Expr, low: Expr, timeperiod: float = 14.0) -> Expr:  # ['aroondown', 'aroonup']
    """AROON(ndarray high, ndarray low, int timeperiod=-0x80000000)

AROON(high, low[, timeperiod=?])

Aroon (Momentum Indicators)

Inputs:
    prices: ['high', 'low']
Parameters:
    timeperiod: 14
Outputs:
    aroondown
    aroonup"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(2)])
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o2(struct_to_numpy(xx, 2, dtype=float), _ta.AROON, timeperiod), return_dtype=dtype)


def AROONOSC(high: Expr, low: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """AROONOSC(ndarray high, ndarray low, int timeperiod=-0x80000000)

AROONOSC(high, low[, timeperiod=?])

Aroon Oscillator (Momentum Indicators)

Inputs:
    prices: ['high', 'low']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.AROONOSC, timeperiod), return_dtype=Float64)


def BOP(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    """BOP(ndarray open, ndarray high, ndarray low, ndarray close)

BOP(open, high, low, close)

Balance Of Power (Momentum Indicators)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    real"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.BOP), return_dtype=Float64)


def CCI(high: Expr, low: Expr, close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """CCI(ndarray high, ndarray low, ndarray close, int timeperiod=-0x80000000)

CCI(high, low, close[, timeperiod=?])

Commodity Channel Index (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.CCI, timeperiod), return_dtype=Float64)


def CMO(close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """CMO(ndarray real, int timeperiod=-0x80000000)

CMO(real[, timeperiod=?])

Chande Momentum Oscillator (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.CMO, timeperiod), return_dtype=Float64)


def DX(high: Expr, low: Expr, close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """DX(ndarray high, ndarray low, ndarray close, int timeperiod=-0x80000000)

DX(high, low, close[, timeperiod=?])

Directional Movement Index (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.DX, timeperiod), return_dtype=Float64)


def MACD(close: Expr, fastperiod: float = 12.0, slowperiod: float = 26.0, signalperiod: float = 9.0) -> Expr:  # ['macd', 'macdsignal', 'macdhist']
    """MACD(ndarray real, int fastperiod=-0x80000000, int slowperiod=-0x80000000, int signalperiod=-0x80000000)

MACD(real[, fastperiod=?, slowperiod=?, signalperiod=?])

Moving Average Convergence/Divergence (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    fastperiod: 12
    slowperiod: 26
    signalperiod: 9
Outputs:
    macd
    macdsignal
    macdhist"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(3)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MACD, fastperiod, slowperiod, signalperiod), return_dtype=dtype)


def MACDEXT(close: Expr, fastperiod: float = 12.0, fastmatype: float = 0.0, slowperiod: float = 26.0, slowmatype: float = 0.0, signalperiod: float = 9.0, signalmatype: float = 0.0) -> Expr:  # ['macd', 'macdsignal', 'macdhist']
    """MACDEXT(ndarray real, int fastperiod=-0x80000000, int fastmatype=0, int slowperiod=-0x80000000, int slowmatype=0, int signalperiod=-0x80000000, int signalmatype=0)

MACDEXT(real[, fastperiod=?, fastmatype=?, slowperiod=?, slowmatype=?, signalperiod=?, signalmatype=?])

MACD with controllable MA type (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    fastperiod: 12
    fastmatype: 0
    slowperiod: 26
    slowmatype: 0
    signalperiod: 9
    signalmatype: 0
Outputs:
    macd
    macdsignal
    macdhist"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(3)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MACDEXT, fastperiod, fastmatype, slowperiod, slowmatype, signalperiod, signalmatype), return_dtype=dtype)


def MACDFIX(close: Expr, signalperiod: float = 9.0) -> Expr:  # ['macd', 'macdsignal', 'macdhist']
    """MACDFIX(ndarray real, int signalperiod=-0x80000000)

MACDFIX(real[, signalperiod=?])

Moving Average Convergence/Divergence Fix 12/26 (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    signalperiod: 9
Outputs:
    macd
    macdsignal
    macdhist"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(3)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MACDFIX, signalperiod), return_dtype=dtype)


def MFI(high: Expr, low: Expr, close: Expr, volume: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """MFI(ndarray high, ndarray low, ndarray close, ndarray volume, int timeperiod=-0x80000000)

MFI(high, low, close, volume[, timeperiod=?])

Money Flow Index (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close', 'volume']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close, f3=volume).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.MFI, timeperiod), return_dtype=Float64)


def MINUS_DI(high: Expr, low: Expr, close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """MINUS_DI(ndarray high, ndarray low, ndarray close, int timeperiod=-0x80000000)

MINUS_DI(high, low, close[, timeperiod=?])

Minus Directional Indicator (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.MINUS_DI, timeperiod), return_dtype=Float64)


def MINUS_DM(high: Expr, low: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """MINUS_DM(ndarray high, ndarray low, int timeperiod=-0x80000000)

MINUS_DM(high, low[, timeperiod=?])

Minus Directional Movement (Momentum Indicators)

Inputs:
    prices: ['high', 'low']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.MINUS_DM, timeperiod), return_dtype=Float64)


def MOM(close: Expr, timeperiod: float = 10.0) -> Expr:  # ['real']
    """MOM(ndarray real, int timeperiod=-0x80000000)

MOM(real[, timeperiod=?])

Momentum (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 10
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MOM, timeperiod), return_dtype=Float64)


def PLUS_DI(high: Expr, low: Expr, close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """PLUS_DI(ndarray high, ndarray low, ndarray close, int timeperiod=-0x80000000)

PLUS_DI(high, low, close[, timeperiod=?])

Plus Directional Indicator (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.PLUS_DI, timeperiod), return_dtype=Float64)


def PLUS_DM(high: Expr, low: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """PLUS_DM(ndarray high, ndarray low, int timeperiod=-0x80000000)

PLUS_DM(high, low[, timeperiod=?])

Plus Directional Movement (Momentum Indicators)

Inputs:
    prices: ['high', 'low']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.PLUS_DM, timeperiod), return_dtype=Float64)


def PPO(close: Expr, fastperiod: float = 12.0, slowperiod: float = 26.0, matype: float = 0.0) -> Expr:  # ['real']
    """PPO(ndarray real, int fastperiod=-0x80000000, int slowperiod=-0x80000000, int matype=0)

PPO(real[, fastperiod=?, slowperiod=?, matype=?])

Percentage Price Oscillator (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    fastperiod: 12
    slowperiod: 26
    matype: 0 (Simple Moving Average)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.PPO, fastperiod, slowperiod, matype), return_dtype=Float64)


def ROC(close: Expr, timeperiod: float = 10.0) -> Expr:  # ['real']
    """ROC(ndarray real, int timeperiod=-0x80000000)

ROC(real[, timeperiod=?])

Rate of change : ((real/prevPrice)-1)*100 (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 10
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ROC, timeperiod), return_dtype=Float64)


def ROCP(close: Expr, timeperiod: float = 10.0) -> Expr:  # ['real']
    """ROCP(ndarray real, int timeperiod=-0x80000000)

ROCP(real[, timeperiod=?])

Rate of change Percentage: (real-prevPrice)/prevPrice (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 10
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ROCP, timeperiod), return_dtype=Float64)


def ROCR(close: Expr, timeperiod: float = 10.0) -> Expr:  # ['real']
    """ROCR(ndarray real, int timeperiod=-0x80000000)

ROCR(real[, timeperiod=?])

Rate of change ratio: (real/prevPrice) (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 10
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ROCR, timeperiod), return_dtype=Float64)


def ROCR100(close: Expr, timeperiod: float = 10.0) -> Expr:  # ['real']
    """ROCR100(ndarray real, int timeperiod=-0x80000000)

ROCR100(real[, timeperiod=?])

Rate of change ratio 100 scale: (real/prevPrice)*100 (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 10
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ROCR100, timeperiod), return_dtype=Float64)


def RSI(close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """RSI(ndarray real, int timeperiod=-0x80000000)

RSI(real[, timeperiod=?])

Relative Strength Index (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.RSI, timeperiod), return_dtype=Float64)


def STOCH(high: Expr, low: Expr, close: Expr, fastk_period: float = 5.0, slowk_period: float = 3.0, slowk_matype: float = 0.0, slowd_period: float = 3.0, slowd_matype: float = 0.0) -> Expr:  # ['slowk', 'slowd']
    """STOCH(ndarray high, ndarray low, ndarray close, int fastk_period=-0x80000000, int slowk_period=-0x80000000, int slowk_matype=0, int slowd_period=-0x80000000, int slowd_matype=0)

STOCH(high, low, close[, fastk_period=?, slowk_period=?, slowk_matype=?, slowd_period=?, slowd_matype=?])

Stochastic (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    fastk_period: 5
    slowk_period: 3
    slowk_matype: 0
    slowd_period: 3
    slowd_matype: 0
Outputs:
    slowk
    slowd"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(2)])
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o2(struct_to_numpy(xx, 3, dtype=float), _ta.STOCH, fastk_period, slowk_period, slowk_matype, slowd_period, slowd_matype), return_dtype=dtype)


def STOCHF(high: Expr, low: Expr, close: Expr, fastk_period: float = 5.0, fastd_period: float = 3.0, fastd_matype: float = 0.0) -> Expr:  # ['fastk', 'fastd']
    """STOCHF(ndarray high, ndarray low, ndarray close, int fastk_period=-0x80000000, int fastd_period=-0x80000000, int fastd_matype=0)

STOCHF(high, low, close[, fastk_period=?, fastd_period=?, fastd_matype=?])

Stochastic Fast (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    fastk_period: 5
    fastd_period: 3
    fastd_matype: 0
Outputs:
    fastk
    fastd"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(2)])
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o2(struct_to_numpy(xx, 3, dtype=float), _ta.STOCHF, fastk_period, fastd_period, fastd_matype), return_dtype=dtype)


def STOCHRSI(close: Expr, timeperiod: float = 14.0, fastk_period: float = 5.0, fastd_period: float = 3.0, fastd_matype: float = 0.0) -> Expr:  # ['fastk', 'fastd']
    """STOCHRSI(ndarray real, int timeperiod=-0x80000000, int fastk_period=-0x80000000, int fastd_period=-0x80000000, int fastd_matype=0)

STOCHRSI(real[, timeperiod=?, fastk_period=?, fastd_period=?, fastd_matype=?])

Stochastic Relative Strength Index (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 14
    fastk_period: 5
    fastd_period: 3
    fastd_matype: 0
Outputs:
    fastk
    fastd"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(2)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.STOCHRSI, timeperiod, fastk_period, fastd_period, fastd_matype), return_dtype=dtype)


def TRIX(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """TRIX(ndarray real, int timeperiod=-0x80000000)

TRIX(real[, timeperiod=?])

1-day Rate-Of-Change (ROC) of a Triple Smooth EMA (Momentum Indicators)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TRIX, timeperiod), return_dtype=Float64)


def ULTOSC(high: Expr, low: Expr, close: Expr, timeperiod1: float = 7.0, timeperiod2: float = 14.0, timeperiod3: float = 28.0) -> Expr:  # ['real']
    """ULTOSC(ndarray high, ndarray low, ndarray close, int timeperiod1=-0x80000000, int timeperiod2=-0x80000000, int timeperiod3=-0x80000000)

ULTOSC(high, low, close[, timeperiod1=?, timeperiod2=?, timeperiod3=?])

Ultimate Oscillator (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod1: 7
    timeperiod2: 14
    timeperiod3: 28
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.ULTOSC, timeperiod1, timeperiod2, timeperiod3), return_dtype=Float64)


def WILLR(high: Expr, low: Expr, close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """WILLR(ndarray high, ndarray low, ndarray close, int timeperiod=-0x80000000)

WILLR(high, low, close[, timeperiod=?])

Williams' %R (Momentum Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.WILLR, timeperiod), return_dtype=Float64)


def BBANDS(close: Expr, timeperiod: float = 5.0, nbdevup: float = 2.0, nbdevdn: float = 2.0, matype: float = 0.0) -> Expr:  # ['upperband', 'middleband', 'lowerband']
    """BBANDS(ndarray real, int timeperiod=-0x80000000, double nbdevup=-4e37, double nbdevdn=-4e37, int matype=0)

BBANDS(real[, timeperiod=?, nbdevup=?, nbdevdn=?, matype=?])

Bollinger Bands (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 5
    nbdevup: 2.0
    nbdevdn: 2.0
    matype: 0 (Simple Moving Average)
Outputs:
    upperband
    middleband
    lowerband"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(3)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.BBANDS, timeperiod, nbdevup, nbdevdn, matype), return_dtype=dtype)


def DEMA(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """DEMA(ndarray real, int timeperiod=-0x80000000)

DEMA(real[, timeperiod=?])

Double Exponential Moving Average (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.DEMA, timeperiod), return_dtype=Float64)


def EMA(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """EMA(ndarray real, int timeperiod=-0x80000000)

EMA(real[, timeperiod=?])

Exponential Moving Average (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.EMA, timeperiod), return_dtype=Float64)


def HT_TRENDLINE(close: Expr) -> Expr:  # ['real']
    """HT_TRENDLINE(ndarray real)

HT_TRENDLINE(real)

Hilbert Transform - Instantaneous Trendline (Overlap Studies)

Inputs:
    real: (any ndarray)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.HT_TRENDLINE), return_dtype=Float64)


def KAMA(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """KAMA(ndarray real, int timeperiod=-0x80000000)

KAMA(real[, timeperiod=?])

Kaufman Adaptive Moving Average (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.KAMA, timeperiod), return_dtype=Float64)


def MA(close: Expr, timeperiod: float = 30.0, matype: float = 0.0) -> Expr:  # ['real']
    """MA(ndarray real, int timeperiod=-0x80000000, int matype=0)

MA(real[, timeperiod=?, matype=?])

Moving average (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
    matype: 0 (Simple Moving Average)
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MA, timeperiod, matype), return_dtype=Float64)


def MAMA(close: Expr, fastlimit: float = 0.5, slowlimit: float = 0.05) -> Expr:  # ['mama', 'fama']
    """MAMA(ndarray real, double fastlimit=-4e37, double slowlimit=-4e37)

MAMA(real[, fastlimit=?, slowlimit=?])

MESA Adaptive Moving Average (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    fastlimit: 0.5
    slowlimit: 0.05
Outputs:
    mama
    fama"""
    dtype = Struct([Field(f"column_{i}", Float64) for i in range(2)])
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MAMA, fastlimit, slowlimit), return_dtype=dtype)


def MAVP(close: Expr, periods: Expr, minperiod: float = 2.0, maxperiod: float = 30.0, matype: float = 0.0) -> Expr:  # ['real']
    """MAVP(ndarray real, ndarray periods, int minperiod=-0x80000000, int maxperiod=-0x80000000, int matype=0)

MAVP(real, periods[, minperiod=?, maxperiod=?, matype=?])

Moving average with variable period (Overlap Studies)

Inputs:
    real: (any ndarray)
    periods: (any ndarray)
Parameters:
    minperiod: 2
    maxperiod: 30
    matype: 0 (Simple Moving Average)
Outputs:
    real"""
    return struct(f0=close, f1=periods).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.MAVP, minperiod, maxperiod, matype), return_dtype=Float64)


def MIDPOINT(close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """MIDPOINT(ndarray real, int timeperiod=-0x80000000)

MIDPOINT(real[, timeperiod=?])

MidPoint over period (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MIDPOINT, timeperiod), return_dtype=Float64)


def MIDPRICE(high: Expr, low: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """MIDPRICE(ndarray high, ndarray low, int timeperiod=-0x80000000)

MIDPRICE(high, low[, timeperiod=?])

Midpoint Price over period (Overlap Studies)

Inputs:
    prices: ['high', 'low']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.MIDPRICE, timeperiod), return_dtype=Float64)


def SAR(high: Expr, low: Expr, acceleration: float = 0.02, maximum: float = 0.2) -> Expr:  # ['real']
    """SAR(ndarray high, ndarray low, double acceleration=0.02, double maximum=0.2)

SAR(high, low[, acceleration=?, maximum=?])

Parabolic SAR (Overlap Studies)

Inputs:
    prices: ['high', 'low']
Parameters:
    acceleration: 0.02
    maximum: 0.2
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.SAR, acceleration, maximum), return_dtype=Float64)


def SAREXT(high: Expr, low: Expr, startvalue: float = 0.0, offsetonreverse: float = 0.0, accelerationinitlong: float = 0.02, accelerationlong: float = 0.02, accelerationmaxlong: float = 0.2, accelerationinitshort: float = 0.02, accelerationshort: float = 0.02, accelerationmaxshort: float = 0.2) -> Expr:  # ['real']
    """SAREXT(ndarray high, ndarray low, double startvalue=-4e37, double offsetonreverse=-4e37, double accelerationinitlong=-4e37, double accelerationlong=-4e37, double accelerationmaxlong=-4e37, double accelerationinitshort=-4e37, double accelerationshort=-4e37, double accelerationmaxshort=-4e37)

SAREXT(high, low[, startvalue=?, offsetonreverse=?, accelerationinitlong=?, accelerationlong=?, accelerationmaxlong=?, accelerationinitshort=?, accelerationshort=?, accelerationmaxshort=?])

Parabolic SAR - Extended (Overlap Studies)

Inputs:
    prices: ['high', 'low']
Parameters:
    startvalue: 0.0
    offsetonreverse: 0.0
    accelerationinitlong: 0.02
    accelerationlong: 0.02
    accelerationmaxlong: 0.2
    accelerationinitshort: 0.02
    accelerationshort: 0.02
    accelerationmaxshort: 0.2
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.SAREXT, startvalue, offsetonreverse, accelerationinitlong, accelerationlong, accelerationmaxlong, accelerationinitshort, accelerationshort, accelerationmaxshort), return_dtype=Float64)


def SMA(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """SMA(ndarray real, int timeperiod=-0x80000000)

SMA(real[, timeperiod=?])

Simple Moving Average (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SMA, timeperiod), return_dtype=Float64)


def T3(close: Expr, timeperiod: float = 5.0, vfactor: float = 0.7) -> Expr:  # ['real']
    """T3(ndarray real, int timeperiod=-0x80000000, double vfactor=-4e37)

T3(real[, timeperiod=?, vfactor=?])

Triple Exponential Moving Average (T3) (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 5
    vfactor: 0.7
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.T3, timeperiod, vfactor), return_dtype=Float64)


def TEMA(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """TEMA(ndarray real, int timeperiod=-0x80000000)

TEMA(real[, timeperiod=?])

Triple Exponential Moving Average (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TEMA, timeperiod), return_dtype=Float64)


def TRIMA(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """TRIMA(ndarray real, int timeperiod=-0x80000000)

TRIMA(real[, timeperiod=?])

Triangular Moving Average (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TRIMA, timeperiod), return_dtype=Float64)


def WMA(close: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """WMA(ndarray real, int timeperiod=-0x80000000)

WMA(real[, timeperiod=?])

Weighted Moving Average (Overlap Studies)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.WMA, timeperiod), return_dtype=Float64)


def CDL2CROWS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDL2CROWS(ndarray open, ndarray high, ndarray low, ndarray close)

CDL2CROWS(open, high, low, close)

Two Crows (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDL2CROWS), return_dtype=Int32)


def CDL3BLACKCROWS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDL3BLACKCROWS(ndarray open, ndarray high, ndarray low, ndarray close)

CDL3BLACKCROWS(open, high, low, close)

Three Black Crows (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDL3BLACKCROWS), return_dtype=Int32)


def CDL3INSIDE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDL3INSIDE(ndarray open, ndarray high, ndarray low, ndarray close)

CDL3INSIDE(open, high, low, close)

Three Inside Up/Down (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDL3INSIDE), return_dtype=Int32)


def CDL3LINESTRIKE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDL3LINESTRIKE(ndarray open, ndarray high, ndarray low, ndarray close)

CDL3LINESTRIKE(open, high, low, close)

Three-Line Strike  (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDL3LINESTRIKE), return_dtype=Int32)


def CDL3OUTSIDE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDL3OUTSIDE(ndarray open, ndarray high, ndarray low, ndarray close)

CDL3OUTSIDE(open, high, low, close)

Three Outside Up/Down (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDL3OUTSIDE), return_dtype=Int32)


def CDL3STARSINSOUTH(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDL3STARSINSOUTH(ndarray open, ndarray high, ndarray low, ndarray close)

CDL3STARSINSOUTH(open, high, low, close)

Three Stars In The South (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDL3STARSINSOUTH), return_dtype=Int32)


def CDL3WHITESOLDIERS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDL3WHITESOLDIERS(ndarray open, ndarray high, ndarray low, ndarray close)

CDL3WHITESOLDIERS(open, high, low, close)

Three Advancing White Soldiers (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDL3WHITESOLDIERS), return_dtype=Int32)


def CDLABANDONEDBABY(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    """CDLABANDONEDBABY(ndarray open, ndarray high, ndarray low, ndarray close, double penetration=0.3)

CDLABANDONEDBABY(open, high, low, close[, penetration=?])

Abandoned Baby (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Parameters:
    penetration: 0.3
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLABANDONEDBABY, penetration), return_dtype=Int32)


def CDLADVANCEBLOCK(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLADVANCEBLOCK(ndarray open, ndarray high, ndarray low, ndarray close)

CDLADVANCEBLOCK(open, high, low, close)

Advance Block (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLADVANCEBLOCK), return_dtype=Int32)


def CDLBELTHOLD(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLBELTHOLD(ndarray open, ndarray high, ndarray low, ndarray close)

CDLBELTHOLD(open, high, low, close)

Belt-hold (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLBELTHOLD), return_dtype=Int32)


def CDLBREAKAWAY(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLBREAKAWAY(ndarray open, ndarray high, ndarray low, ndarray close)

CDLBREAKAWAY(open, high, low, close)

Breakaway (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLBREAKAWAY), return_dtype=Int32)


def CDLCLOSINGMARUBOZU(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLCLOSINGMARUBOZU(ndarray open, ndarray high, ndarray low, ndarray close)

CDLCLOSINGMARUBOZU(open, high, low, close)

Closing Marubozu (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLCLOSINGMARUBOZU), return_dtype=Int32)


def CDLCONCEALBABYSWALL(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLCONCEALBABYSWALL(ndarray open, ndarray high, ndarray low, ndarray close)

CDLCONCEALBABYSWALL(open, high, low, close)

Concealing Baby Swallow (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLCONCEALBABYSWALL), return_dtype=Int32)


def CDLCOUNTERATTACK(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLCOUNTERATTACK(ndarray open, ndarray high, ndarray low, ndarray close)

CDLCOUNTERATTACK(open, high, low, close)

Counterattack (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLCOUNTERATTACK), return_dtype=Int32)


def CDLDARKCLOUDCOVER(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.5) -> Expr:  # ['integer']
    """CDLDARKCLOUDCOVER(ndarray open, ndarray high, ndarray low, ndarray close, double penetration=0.5)

CDLDARKCLOUDCOVER(open, high, low, close[, penetration=?])

Dark Cloud Cover (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Parameters:
    penetration: 0.5
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLDARKCLOUDCOVER, penetration), return_dtype=Int32)


def CDLDOJI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLDOJI(ndarray open, ndarray high, ndarray low, ndarray close)

CDLDOJI(open, high, low, close)

Doji (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLDOJI), return_dtype=Int32)


def CDLDOJISTAR(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLDOJISTAR(ndarray open, ndarray high, ndarray low, ndarray close)

CDLDOJISTAR(open, high, low, close)

Doji Star (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLDOJISTAR), return_dtype=Int32)


def CDLDRAGONFLYDOJI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLDRAGONFLYDOJI(ndarray open, ndarray high, ndarray low, ndarray close)

CDLDRAGONFLYDOJI(open, high, low, close)

Dragonfly Doji (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLDRAGONFLYDOJI), return_dtype=Int32)


def CDLENGULFING(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLENGULFING(ndarray open, ndarray high, ndarray low, ndarray close)

CDLENGULFING(open, high, low, close)

Engulfing Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLENGULFING), return_dtype=Int32)


def CDLEVENINGDOJISTAR(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    """CDLEVENINGDOJISTAR(ndarray open, ndarray high, ndarray low, ndarray close, double penetration=0.3)

CDLEVENINGDOJISTAR(open, high, low, close[, penetration=?])

Evening Doji Star (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Parameters:
    penetration: 0.3
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLEVENINGDOJISTAR, penetration), return_dtype=Int32)


def CDLEVENINGSTAR(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    """CDLEVENINGSTAR(ndarray open, ndarray high, ndarray low, ndarray close, double penetration=0.3)

CDLEVENINGSTAR(open, high, low, close[, penetration=?])

Evening Star (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Parameters:
    penetration: 0.3
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLEVENINGSTAR, penetration), return_dtype=Int32)


def CDLGAPSIDESIDEWHITE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLGAPSIDESIDEWHITE(ndarray open, ndarray high, ndarray low, ndarray close)

CDLGAPSIDESIDEWHITE(open, high, low, close)

Up/Down-gap side-by-side white lines (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLGAPSIDESIDEWHITE), return_dtype=Int32)


def CDLGRAVESTONEDOJI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLGRAVESTONEDOJI(ndarray open, ndarray high, ndarray low, ndarray close)

CDLGRAVESTONEDOJI(open, high, low, close)

Gravestone Doji (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLGRAVESTONEDOJI), return_dtype=Int32)


def CDLHAMMER(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLHAMMER(ndarray open, ndarray high, ndarray low, ndarray close)

CDLHAMMER(open, high, low, close)

Hammer (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLHAMMER), return_dtype=Int32)


def CDLHANGINGMAN(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLHANGINGMAN(ndarray open, ndarray high, ndarray low, ndarray close)

CDLHANGINGMAN(open, high, low, close)

Hanging Man (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLHANGINGMAN), return_dtype=Int32)


def CDLHARAMI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLHARAMI(ndarray open, ndarray high, ndarray low, ndarray close)

CDLHARAMI(open, high, low, close)

Harami Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLHARAMI), return_dtype=Int32)


def CDLHARAMICROSS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLHARAMICROSS(ndarray open, ndarray high, ndarray low, ndarray close)

CDLHARAMICROSS(open, high, low, close)

Harami Cross Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLHARAMICROSS), return_dtype=Int32)


def CDLHIGHWAVE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLHIGHWAVE(ndarray open, ndarray high, ndarray low, ndarray close)

CDLHIGHWAVE(open, high, low, close)

High-Wave Candle (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLHIGHWAVE), return_dtype=Int32)


def CDLHIKKAKE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLHIKKAKE(ndarray open, ndarray high, ndarray low, ndarray close)

CDLHIKKAKE(open, high, low, close)

Hikkake Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLHIKKAKE), return_dtype=Int32)


def CDLHIKKAKEMOD(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLHIKKAKEMOD(ndarray open, ndarray high, ndarray low, ndarray close)

CDLHIKKAKEMOD(open, high, low, close)

Modified Hikkake Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLHIKKAKEMOD), return_dtype=Int32)


def CDLHOMINGPIGEON(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLHOMINGPIGEON(ndarray open, ndarray high, ndarray low, ndarray close)

CDLHOMINGPIGEON(open, high, low, close)

Homing Pigeon (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLHOMINGPIGEON), return_dtype=Int32)


def CDLIDENTICAL3CROWS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLIDENTICAL3CROWS(ndarray open, ndarray high, ndarray low, ndarray close)

CDLIDENTICAL3CROWS(open, high, low, close)

Identical Three Crows (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLIDENTICAL3CROWS), return_dtype=Int32)


def CDLINNECK(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLINNECK(ndarray open, ndarray high, ndarray low, ndarray close)

CDLINNECK(open, high, low, close)

In-Neck Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLINNECK), return_dtype=Int32)


def CDLINVERTEDHAMMER(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLINVERTEDHAMMER(ndarray open, ndarray high, ndarray low, ndarray close)

CDLINVERTEDHAMMER(open, high, low, close)

Inverted Hammer (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLINVERTEDHAMMER), return_dtype=Int32)


def CDLKICKING(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLKICKING(ndarray open, ndarray high, ndarray low, ndarray close)

CDLKICKING(open, high, low, close)

Kicking (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLKICKING), return_dtype=Int32)


def CDLKICKINGBYLENGTH(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLKICKINGBYLENGTH(ndarray open, ndarray high, ndarray low, ndarray close)

CDLKICKINGBYLENGTH(open, high, low, close)

Kicking - bull/bear determined by the longer marubozu (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLKICKINGBYLENGTH), return_dtype=Int32)


def CDLLADDERBOTTOM(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLLADDERBOTTOM(ndarray open, ndarray high, ndarray low, ndarray close)

CDLLADDERBOTTOM(open, high, low, close)

Ladder Bottom (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLLADDERBOTTOM), return_dtype=Int32)


def CDLLONGLEGGEDDOJI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLLONGLEGGEDDOJI(ndarray open, ndarray high, ndarray low, ndarray close)

CDLLONGLEGGEDDOJI(open, high, low, close)

Long Legged Doji (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLLONGLEGGEDDOJI), return_dtype=Int32)


def CDLLONGLINE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLLONGLINE(ndarray open, ndarray high, ndarray low, ndarray close)

CDLLONGLINE(open, high, low, close)

Long Line Candle (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLLONGLINE), return_dtype=Int32)


def CDLMARUBOZU(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLMARUBOZU(ndarray open, ndarray high, ndarray low, ndarray close)

CDLMARUBOZU(open, high, low, close)

Marubozu (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLMARUBOZU), return_dtype=Int32)


def CDLMATCHINGLOW(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLMATCHINGLOW(ndarray open, ndarray high, ndarray low, ndarray close)

CDLMATCHINGLOW(open, high, low, close)

Matching Low (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLMATCHINGLOW), return_dtype=Int32)


def CDLMATHOLD(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.5) -> Expr:  # ['integer']
    """CDLMATHOLD(ndarray open, ndarray high, ndarray low, ndarray close, double penetration=0.5)

CDLMATHOLD(open, high, low, close[, penetration=?])

Mat Hold (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Parameters:
    penetration: 0.5
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLMATHOLD, penetration), return_dtype=Int32)


def CDLMORNINGDOJISTAR(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    """CDLMORNINGDOJISTAR(ndarray open, ndarray high, ndarray low, ndarray close, double penetration=0.3)

CDLMORNINGDOJISTAR(open, high, low, close[, penetration=?])

Morning Doji Star (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Parameters:
    penetration: 0.3
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLMORNINGDOJISTAR, penetration), return_dtype=Int32)


def CDLMORNINGSTAR(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    """CDLMORNINGSTAR(ndarray open, ndarray high, ndarray low, ndarray close, double penetration=0.3)

CDLMORNINGSTAR(open, high, low, close[, penetration=?])

Morning Star (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Parameters:
    penetration: 0.3
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLMORNINGSTAR, penetration), return_dtype=Int32)


def CDLONNECK(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLONNECK(ndarray open, ndarray high, ndarray low, ndarray close)

CDLONNECK(open, high, low, close)

On-Neck Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLONNECK), return_dtype=Int32)


def CDLPIERCING(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLPIERCING(ndarray open, ndarray high, ndarray low, ndarray close)

CDLPIERCING(open, high, low, close)

Piercing Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLPIERCING), return_dtype=Int32)


def CDLRICKSHAWMAN(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLRICKSHAWMAN(ndarray open, ndarray high, ndarray low, ndarray close)

CDLRICKSHAWMAN(open, high, low, close)

Rickshaw Man (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLRICKSHAWMAN), return_dtype=Int32)


def CDLRISEFALL3METHODS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLRISEFALL3METHODS(ndarray open, ndarray high, ndarray low, ndarray close)

CDLRISEFALL3METHODS(open, high, low, close)

Rising/Falling Three Methods (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLRISEFALL3METHODS), return_dtype=Int32)


def CDLSEPARATINGLINES(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLSEPARATINGLINES(ndarray open, ndarray high, ndarray low, ndarray close)

CDLSEPARATINGLINES(open, high, low, close)

Separating Lines (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLSEPARATINGLINES), return_dtype=Int32)


def CDLSHOOTINGSTAR(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLSHOOTINGSTAR(ndarray open, ndarray high, ndarray low, ndarray close)

CDLSHOOTINGSTAR(open, high, low, close)

Shooting Star (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLSHOOTINGSTAR), return_dtype=Int32)


def CDLSHORTLINE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLSHORTLINE(ndarray open, ndarray high, ndarray low, ndarray close)

CDLSHORTLINE(open, high, low, close)

Short Line Candle (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLSHORTLINE), return_dtype=Int32)


def CDLSPINNINGTOP(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLSPINNINGTOP(ndarray open, ndarray high, ndarray low, ndarray close)

CDLSPINNINGTOP(open, high, low, close)

Spinning Top (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLSPINNINGTOP), return_dtype=Int32)


def CDLSTALLEDPATTERN(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLSTALLEDPATTERN(ndarray open, ndarray high, ndarray low, ndarray close)

CDLSTALLEDPATTERN(open, high, low, close)

Stalled Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLSTALLEDPATTERN), return_dtype=Int32)


def CDLSTICKSANDWICH(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLSTICKSANDWICH(ndarray open, ndarray high, ndarray low, ndarray close)

CDLSTICKSANDWICH(open, high, low, close)

Stick Sandwich (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLSTICKSANDWICH), return_dtype=Int32)


def CDLTAKURI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLTAKURI(ndarray open, ndarray high, ndarray low, ndarray close)

CDLTAKURI(open, high, low, close)

Takuri (Dragonfly Doji with very long lower shadow) (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLTAKURI), return_dtype=Int32)


def CDLTASUKIGAP(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLTASUKIGAP(ndarray open, ndarray high, ndarray low, ndarray close)

CDLTASUKIGAP(open, high, low, close)

Tasuki Gap (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLTASUKIGAP), return_dtype=Int32)


def CDLTHRUSTING(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLTHRUSTING(ndarray open, ndarray high, ndarray low, ndarray close)

CDLTHRUSTING(open, high, low, close)

Thrusting Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLTHRUSTING), return_dtype=Int32)


def CDLTRISTAR(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLTRISTAR(ndarray open, ndarray high, ndarray low, ndarray close)

CDLTRISTAR(open, high, low, close)

Tristar Pattern (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLTRISTAR), return_dtype=Int32)


def CDLUNIQUE3RIVER(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLUNIQUE3RIVER(ndarray open, ndarray high, ndarray low, ndarray close)

CDLUNIQUE3RIVER(open, high, low, close)

Unique 3 River (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLUNIQUE3RIVER), return_dtype=Int32)


def CDLUPSIDEGAP2CROWS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLUPSIDEGAP2CROWS(ndarray open, ndarray high, ndarray low, ndarray close)

CDLUPSIDEGAP2CROWS(open, high, low, close)

Upside Gap Two Crows (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLUPSIDEGAP2CROWS), return_dtype=Int32)


def CDLXSIDEGAP3METHODS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    """CDLXSIDEGAP3METHODS(ndarray open, ndarray high, ndarray low, ndarray close)

CDLXSIDEGAP3METHODS(open, high, low, close)

Upside/Downside Gap Three Methods (Pattern Recognition)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    integer (values are -100, 0 or 100)"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.CDLXSIDEGAP3METHODS), return_dtype=Int32)


def AVGPRICE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    """AVGPRICE(ndarray open, ndarray high, ndarray low, ndarray close)

AVGPRICE(open, high, low, close)

Average Price (Price Transform)

Inputs:
    prices: ['open', 'high', 'low', 'close']
Outputs:
    real"""
    return struct(f0=open, f1=high, f2=low, f3=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.AVGPRICE), return_dtype=Float64)


def MEDPRICE(high: Expr, low: Expr) -> Expr:  # ['real']
    """MEDPRICE(ndarray high, ndarray low)

MEDPRICE(high, low)

Median Price (Price Transform)

Inputs:
    prices: ['high', 'low']
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.MEDPRICE), return_dtype=Float64)


def TYPPRICE(high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    """TYPPRICE(ndarray high, ndarray low, ndarray close)

TYPPRICE(high, low, close)

Typical Price (Price Transform)

Inputs:
    prices: ['high', 'low', 'close']
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.TYPPRICE), return_dtype=Float64)


def WCLPRICE(high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    """WCLPRICE(ndarray high, ndarray low, ndarray close)

WCLPRICE(high, low, close)

Weighted Close Price (Price Transform)

Inputs:
    prices: ['high', 'low', 'close']
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.WCLPRICE), return_dtype=Float64)


def BETA(high: Expr, low: Expr, timeperiod: float = 5.0) -> Expr:  # ['real']
    """BETA(ndarray real0, ndarray real1, int timeperiod=-0x80000000)

BETA(real0, real1[, timeperiod=?])

Beta (Statistic Functions)

Inputs:
    real0: (any ndarray)
    real1: (any ndarray)
Parameters:
    timeperiod: 5
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.BETA, timeperiod), return_dtype=Float64)


def CORREL(high: Expr, low: Expr, timeperiod: float = 30.0) -> Expr:  # ['real']
    """CORREL(ndarray real0, ndarray real1, int timeperiod=-0x80000000)

CORREL(real0, real1[, timeperiod=?])

Pearson's Correlation Coefficient (r) (Statistic Functions)

Inputs:
    real0: (any ndarray)
    real1: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real"""
    return struct(f0=high, f1=low).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.CORREL, timeperiod), return_dtype=Float64)


def LINEARREG(close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """LINEARREG(ndarray real, int timeperiod=-0x80000000)

LINEARREG(real[, timeperiod=?])

Linear Regression (Statistic Functions)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LINEARREG, timeperiod), return_dtype=Float64)


def LINEARREG_ANGLE(close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """LINEARREG_ANGLE(ndarray real, int timeperiod=-0x80000000)

LINEARREG_ANGLE(real[, timeperiod=?])

Linear Regression Angle (Statistic Functions)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LINEARREG_ANGLE, timeperiod), return_dtype=Float64)


def LINEARREG_INTERCEPT(close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """LINEARREG_INTERCEPT(ndarray real, int timeperiod=-0x80000000)

LINEARREG_INTERCEPT(real[, timeperiod=?])

Linear Regression Intercept (Statistic Functions)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LINEARREG_INTERCEPT, timeperiod), return_dtype=Float64)


def LINEARREG_SLOPE(close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """LINEARREG_SLOPE(ndarray real, int timeperiod=-0x80000000)

LINEARREG_SLOPE(real[, timeperiod=?])

Linear Regression Slope (Statistic Functions)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LINEARREG_SLOPE, timeperiod), return_dtype=Float64)


def STDDEV(close: Expr, timeperiod: float = 5.0, nbdev: float = 1.0) -> Expr:  # ['real']
    """STDDEV(ndarray real, int timeperiod=-0x80000000, double nbdev=-4e37)

STDDEV(real[, timeperiod=?, nbdev=?])

Standard Deviation (Statistic Functions)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 5
    nbdev: 1.0
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.STDDEV, timeperiod, nbdev), return_dtype=Float64)


def TSF(close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """TSF(ndarray real, int timeperiod=-0x80000000)

TSF(real[, timeperiod=?])

Time Series Forecast (Statistic Functions)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TSF, timeperiod), return_dtype=Float64)


def VAR(close: Expr, timeperiod: float = 5.0, nbdev: float = 1.0) -> Expr:  # ['real']
    """VAR(ndarray real, int timeperiod=-0x80000000, double nbdev=-4e37)

VAR(real[, timeperiod=?, nbdev=?])

Variance (Statistic Functions)

Inputs:
    real: (any ndarray)
Parameters:
    timeperiod: 5
    nbdev: 1.0
Outputs:
    real"""
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.VAR, timeperiod, nbdev), return_dtype=Float64)


def ATR(high: Expr, low: Expr, close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """ATR(ndarray high, ndarray low, ndarray close, int timeperiod=-0x80000000)

ATR(high, low, close[, timeperiod=?])

Average True Range (Volatility Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.ATR, timeperiod), return_dtype=Float64)


def NATR(high: Expr, low: Expr, close: Expr, timeperiod: float = 14.0) -> Expr:  # ['real']
    """NATR(ndarray high, ndarray low, ndarray close, int timeperiod=-0x80000000)

NATR(high, low, close[, timeperiod=?])

Normalized Average True Range (Volatility Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Parameters:
    timeperiod: 14
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.NATR, timeperiod), return_dtype=Float64)


def TRANGE(high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    """TRANGE(ndarray high, ndarray low, ndarray close)

TRANGE(high, low, close)

True Range (Volatility Indicators)

Inputs:
    prices: ['high', 'low', 'close']
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 3, dtype=float), _ta.TRANGE), return_dtype=Float64)


def AD(high: Expr, low: Expr, close: Expr, volume: Expr) -> Expr:  # ['real']
    """AD(ndarray high, ndarray low, ndarray close, ndarray volume)

AD(high, low, close, volume)

Chaikin A/D Line (Volume Indicators)

Inputs:
    prices: ['high', 'low', 'close', 'volume']
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close, f3=volume).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.AD), return_dtype=Float64)


def ADOSC(high: Expr, low: Expr, close: Expr, volume: Expr, fastperiod: float = 3.0, slowperiod: float = 10.0) -> Expr:  # ['real']
    """ADOSC(ndarray high, ndarray low, ndarray close, ndarray volume, int fastperiod=-0x80000000, int slowperiod=-0x80000000)

ADOSC(high, low, close, volume[, fastperiod=?, slowperiod=?])

Chaikin A/D Oscillator (Volume Indicators)

Inputs:
    prices: ['high', 'low', 'close', 'volume']
Parameters:
    fastperiod: 3
    slowperiod: 10
Outputs:
    real"""
    return struct(f0=high, f1=low, f2=close, f3=volume).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 4, dtype=float), _ta.ADOSC, fastperiod, slowperiod), return_dtype=Float64)


def OBV(close: Expr, volume: Expr) -> Expr:  # ['real']
    """OBV(ndarray real, ndarray volume)

OBV(real, volume)

On Balance Volume (Volume Indicators)

Inputs:
    real: (any ndarray)
    prices: ['volume']
Outputs:
    real"""
    return struct(f0=close, f1=volume).map_batches(lambda xx: batches_i2_o1(struct_to_numpy(xx, 2, dtype=float), _ta.OBV), return_dtype=Float64)
